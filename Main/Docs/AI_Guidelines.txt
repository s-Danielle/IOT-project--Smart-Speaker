You are an AI coding assistant working on a Raspberry-Pi Smart Speaker project.
Your goal is to implement a modular, maintainable system with a clear state machine and clean separation of hardware, UI, and logic.

Follow this architecture and behaviors exactly.

ğŸ“š Project Architecture Requirements
IOT-project--Smart-Speaker/Main
â”‚
â”œâ”€ main.py                          # Entry point: create controller + run loop
â”‚
â”œâ”€ core/                            # App logic (state machine + orchestrator)
â”‚  â”œâ”€ controller.py                 # Main loop: polls inputs, updates state
â”‚  â”œâ”€ state.py                      # Enums + dataclasses for device state
â”‚  â””â”€ actions.py                    # Pure action handlers (play, stop, recordâ€¦)
â”‚
â”œâ”€ io/                              # Hardware + system interfaces (no logic)
â”‚  â”œâ”€ nfc_scanner.py                # PN532 NFC reader (non-blocking read_uid)
â”‚  â”œâ”€ chip_store.py                 # Load chips.json, UID lookup
â”‚  â”œâ”€ buttons.py                    # PCF8574 or GPIO wrapper, returns raw states
â”‚  â”œâ”€ audio_player.py               # Mopidy wrapper: play_uri, pause, stop
â”‚  â”œâ”€ recorder.py                   # Start/stop/cancel recordings (arecord)
â”‚  â”œâ”€ leds.py                       # APA102 LED wrapper (colors, blink patterns)
â”‚  â””â”€ health.py                     # Wrap health_check: run startup diagnostics
â”‚
â”œâ”€ ui/                              # User-facing feedback: beeps + lights
â”‚  â”œâ”€ sounds.py                     # Play WAVs (chip-loaded beep, error beepâ€¦)
â”‚  â”œâ”€ lights.py                     # High-level LED states (idle, playingâ€¦)
â”‚  â””â”€ ui_controller.py              # Sound+light combined events (on_play(), etc.)
â”‚
â”œâ”€ config/                          # Static configuration & paths
â”‚  â”œâ”€ tags.json                     # UID â†’ {name, uri, ...}
â”‚  â”œâ”€ settings.py                   # Constants: timings, I2C addresses, etc.
â”‚  â””â”€ paths.py                      # Central paths for sound files, recordings, chips.json
â”‚
â”œâ”€ assets/
â”‚  â””â”€ sounds/                       # UI WAV files
â”‚       chip_loaded.wav
â”‚       play.wav
â”‚       pause.wav
â”‚       stop.wav
â”‚       error.wav
â”‚       record_start.wav
â”‚       record_saved.wav
â”‚       record_canceled.wav
â”‚       blocked.wav
â”‚
â”œâ”€ recordings/
â”‚
â”œâ”€ docs/



You must implement a main loop controller that:

Initializes:

NFC reader (PN532)

Button reader (PCF8574 or GPIO)

Audio player (Mopidy)

Recorder (arecord)

LEDs + UI sounds

Chip store (chips.json)

Health check

Runs a non-blocking infinite loop:

Poll NFC

Poll buttons

Detect edges + long presses

Dispatch to actions based on the current state and user events

Trigger UI feedback (sounds + LEDs)

Sleep a very short interval (e.g. 50ms)

Maintains an explicit state machine (stored in core/state.py).

Calls pure action functions from core/actions.py (no hardware code inside actions).

Keeps all hardware I/O inside io/ modules, and all feedback inside ui/ modules.

ğŸ”µ States

Implement these states clearly:

IDLE_NO_CHIP

IDLE_CHIP_LOADED

PLAYING

PAUSED

RECORDING

Use enums or simple class constants.

ğŸ”˜ Buttons

Three buttons:

Play/Pause

Record (long-press 3s to arm â†’ release to start recording â†’ short press to save)

Stop (short press: stop; long press 5s: clear chip)

Buttons are active-low.
Button module should expose clean events:

pressed

released

hold duration

Controller handles timing.

ğŸŸª NFC Behavior (PN532)

Scanning a chip loads the chip (no auto-play).

Scanning the same chip does nothing.

Scanning a different chip replaces the loaded chip and returns to IDLE_CHIP_LOADED.

During recording, NFC scans are ignored.

ğŸ”Š Audio & Recording Behavior
Playback:

Play/Pause toggles between PLAYING and PAUSED.

Stop stops playback and returns to IDLE_CHIP_LOADED.

Clearing chip removes the loaded chip and goes to IDLE_NO_CHIP.

Recording:

Can only start when a chip is loaded.

User must hold Record for 3 seconds â†’ release â†’ recording begins.

Music auto-pauses during recording.

Short press Record stops + saves the recording.

Short press Stop cancels (no save).

Long press Stop (5s) cancels + clears chip.

After saving, if music was previously playing, return to PAUSED.

ğŸŸ© UI Feedback Requirements

Implement a ui_controller.py that exposes unified feedback functions:

on_chip_loaded()

on_play()

on_pause()

on_stop()

on_clear_chip()

on_record_start()

on_record_saved()

on_record_canceled()

on_blocked_action()

These should call:

ui/sounds.py for WAV playback

ui/lights.py for LEDs

No sounds or LED code should exist outside ui/.

ğŸ§  Design Principles

Main loop must remain simple and non-blocking.

controller.py handles:

reading inputs

long-press logic

mapping events to actions

updating state

calling UI events

actions.py contains pure logic:

updating state

calling appropriate I/O

calling UI feedback

Hardware is fully encapsulated in io/.

UI is fully encapsulated in ui/.

All constants (timings, I2C addresses, file paths) live in config/settings.py or config/paths.py.

Extensible for future â€œvoice â†’ text â†’ intent â†’ actionâ€ LLM integration (optional).
Keep actions callable from any input source.